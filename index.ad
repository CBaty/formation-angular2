= Angular 2
:author: Arnaud Tournier - @ltearno - LTE Consulting - 2017 - Toulouse
:email: ltearno@gmail.com
:backend: revealjs
:imagesdir: images
:revealjs_theme: white
:revealjs_history: true
:source-highlighter: highlightjs
:revealjs_width: 1600
:revealjs_height: 1200
:revealjs_hideaddressbar: true
:revealjs_mousewheel: true
:revealjs_slidenumber: true
:revealjs_transitionspeed: fast
:revealjs_fragments: true
////
:source-highlighter: coderay
:revealjs_transition: zoom
:source-highlighter: pygments
////

== Arnaud Tournier

Email: ltearno@gmail.com

Twitter: https://twitter.com/ltearno[@ltearno]

Web: http://www.lteconsulting.fr[www.lteconsulting.fr]

== ECMASCRIPT 6

Spécification standardisée du Javascript : ECMAScript.

La version 5 est la plus largement répandue aujourd'hui.

La version suivante est ECMAScript 6 (ou ES6, ou ECMASCRIPT 2015). Elle propose de nombreuses fonctionnalités comme les _classes_, les _constantes_, les _arrow functions_, les _générateurs_...

Angular se base sur cette version d'ECMAScript, bien qu'une API existe pour écrire des applications en ECMAScript 5.

Les navigateurs modernes sont déjà à jour pour cette version. Il existe des transpileurs (Babeljs, Traceur par exemple) pour générer du code ECMAScript 5 à partir de code en version 6.

Nous allons découvrir les nouveautés d'ECMAScript à connaître impérativement pour avoir une expérience de développement optimale avec Angular.

Ces nouveautés permettent en général soit de corriger un défaut du langage javascript, soit d'amener un _sucre syntaxique_ permettant d'exprimer des constructions issues des languages _POO_. D'autres améliorations permettent tout simplement d'être plus efficace dans son développement. Enfin, l'ensemble des améliorations permet un meilleur traitement des sources dans les environnements de développement (IDE).

=== `;` optionnel

Le point-virgule `;` est désormais optionnel dans les sources Javascript.

Sauf rares cas, il est pratiquement possible de purement et simplement les supprimer de vos sources.

=== `let`

[source,language=javascript]
----
let maVariable = 5
----

Le mot-clé `let` corrige les défauts de `var` utilisé pour déclarer des variables en Javascript, notamment :

- la portée des variable. Les variables `let` ont une durée de vie limitée au bloc dans lequel elles se trouvent. Et non à la _fonction_ dans laquelle elles se trouvent.
- le _hoisting_. Les variables `let` ne sont pas accessibles avant la ligne qui les déclare.

La déclaration de variable en Javascript se comporte enfin de la manière attendue !

=== `const`

[source,language=javascript]
----
const maConstante = 53

// provoque une erreur :
maConstante = 42
----

Le mot-clé `const` permet de déclarer une constante, c'est à dire une variable dont on ne peut pas changer la valeur.

C'est une fonctionnalité de language qui manquait à Javascript.

=== Construction rapide d'objets

Une nouvelle forme de syntaxe pour créer des objets rapidement :

[source,language=javascript]
----
function creerUser( nom, prenom ) {
  return {
    nom, <1>
    prenom
  }
}
----
<1> La propriété de l'objet aura le même nom que la variable utilisée comme valeur

est équivalent à :

[source,language=javascript]
----
function creerUser( nom, prenom ) {
  return {
    nom: nom,
    prenom: prenom
  }
}
----

=== Affectations destructurées

Nouvelle syntaxe qui permet de facilement affecter des variables à partir de propriétés d'objets ou d'éléments de tableaux.

En ES5, pour extraire des variables à partir d'un objet, on écrit souvent :

[source,language=javascript]
----
// en entrée un objet data = { id: 3, name: 'toto' }
var id = data.id;
var name = data.name;
----

L'affectation destructurée permet ceci :

[source,language=javascript]
----
let { id, name } = data <1>
----
<1> L'affectation destructurée déclare et initialise les variables `id` et `name`.

Si on souhaite affecter des variables avec des noms différents des propriétés de l'objet, on peut faire ainsi :

[source,language=javascript]
----
let { id: userId, name: userName } = data <1>
----
<1> L'affectation destructurée déclare et initialise les variables `userId` et `userName`.

Ceci fonctionne aussi avec les objets imbriqués :

[source,language=javascript]
----
let { id: userId, address: { street: userStreet } } = data
----

Cette syntaxe fonctionne aussi avec les tableaux :

[source,language=javascript]
----
// avec un tableau t = [3, 6, 4, 7]

let [ premier, deuxieme ] = t
----

=== L'opérateur de reste

Cet opérateur permet d'accepter facilement un nombre de paramètres variable dans une fonction :

[source,language=javascript]
----
function ajouterProduits( ...produits ) {
  for(let produit of produits) {
    ...
  }
}
----

On peut aussi utiliser cet opérateur avec les affectations destructurées :

[source,language=javascript]
----
let [head, ...tail] = list <1>
----
<1> `head` contient le premier élément et `tail` la suite de la liste

=== L'opérateur d'étalement

C'est le complémentaire de l'opérateur de reste. Il permet de _convertir_ un tableau en liste d'arguments :

[source,language=javascript]
----
let coordonnees = [12, 32]
let point = new Point(...coordonnees)
----

=== Valeurs par défaut

Il est maintenant possible de donner des valeurs par défaut aux paramètres de fonctions et éléments d'affectation destructurée.

Au lieu d'écrire :

[source,language=javascript]
----
function faireChose( size, value ) {
  value = value || 0 // valeur par défaut
}
----

On préfèrera :

[source,language=javascript]
----
function faireChose( size, value = 0 ) {
}
----

La valeur par défaut peut aussi être un appel de fonction, ou même une expression faisant référence à d'autres paramètres de la fonction (_quand ils sont à gauche de là où on les utilise_). Voyez cet exemple :

[source,language=javascript]
----
function autreChose( factory = defaultFactory(), type = factory.type ) { <1>
}
----
<1> la fonction `defaultFactory` ne sera appelée que lorsque l'appelant ne fournit pas de valeur au paramètre. Si le deuxième paramètre n'est pas fourni, sa valeur sera affectée à l'expression `factory.type`.

Utilisée avec l'affectation destructurée des variables, cette construction s'écrit :

[source,language=javascript]
----
const { timeout = 1000 } = httpOptions
----

=== Les classes

L'introduction des classes en Javascript se fait par l'ajout d'une syntaxe équivalente à un _sucre syntaxique_ pour le moteur d'exécution JS. En effet javascript repose sur un modèle d'héritage par prototype qui permet de simuler l'héritage de classes.

Voici un exemple de classe :

[source,language=javascript]
----
class Livre {
  constructor(private titre) { <1> <2>
  }
  
  description() {
    return `Livre: ${this.titre}`
  }

  static fonctionStatique(toto) {
    return toto
  }
}

let livre = new Livre('Les frameworks JS')

----
<1> la fonction spéciale `constructor` est appelée lorsque l'objet est créé.
<2> l'utilisation de `private` ou `public` crée automatiquement un attribut dans la classe (Typescript seulement ?).

=== Accesseurs

Une classe peut fournir des fonctions _getter_ et/ou _setter_ en plus des attributs classiques.

[source,language=javascript]
----
class EditionService {
  get description() { <1>
    return `service ${this.name}`
  }

  private value

  set longueur(value) { <2>
    if(value.charAt(value.length-1)=='k')
      this._value = value * 1000
    else
      this.value = value
  }
}

let service = new EditionService()

console.log(service.description)

service.longueur = '100k'
service.longueur = 24
----
<1> le mot-clé `get` permet de déclarer un accesseur _getter_ pour la propriété `description`.
<2> le mot-clé `set` permet de déclarer un accesseur _setter_ pour la propriété `longueur`.

=== Héritage

L'héritage de classe est possible avec le mot-clé `extends` :

[source,language=javascript]
----
class Animal {
  constructor(private name) {}
}

class Mamifere extends Animal {
  constructor() {
    super('baleine') <1>
  }

  affiche() {
    console.log('je suis une baleine')

    super.affiche() <2>
  }
}
----
<1> le mot-clé `super` permet de faire référence au constructeur de la classe parente.
<2> le mot-clé `super` permet de faire référence à l'implémentation de la fonction dans la classe parente.

=== Les promises

Avec les versions précédentes de Javascript et l'utilisation intensive des traitements asynchrones, de nombreuses bibliothèques de _promises_ ont vu le jour ces dernières années. Avec même la création de certains standards _de-facto_.

ES5 apporte une normalisation de la gestion des traitements asynchrones avec les _Promises_. Cette API permet d'éviter le _callback hell_.

Une _promise_ est un objet qui représente la mise à disposition d'un résultat _plus tard_ dans le temps. On peut dire qu'il s'agit de la représentation d'un traitement asynchrone.

On peut chainer les traitements asynchrones grâce à la fonction `then` des `Promise`.

[source,language=javascript]
----
this.userService.getUser(id) <1>
  .then( function(user) { return this.userService.getRights() } ) <2>
  .then( function(rights) { this.doSomething(rights) } ) <3>
----
<1> la fonction `getUser()` retourne une `Promise`.
<2> l'appel à la fonction `then` permet de spécifier la fonction qui sera appelée quand la première promesse aura fourni son résultat. Le traitement suivant est retourné, c'est-à-dire la promesse retournée par la fonction `getRights()`. Une valeur aurait pu être directement retournée.
<3> on peut chaîner les appels à `then` pour faire des traitements successifs. Chaque fonction de rappel reçoit le résultat du traitement précédent. Ici aucune valeur n'est retournée pour le potentiel prochain traitement.

=== Les promises

Une promesse peut être dans un des trois états suivants : _pending_, _fulfilled_ ou _rejected_.

Lorsqu'une promesse est rejetée, on peut récupérer l'erreur en passant une fonction de rappel en deuxième paramètre de `then`.

[source,language=javascript]
----
this.userService.getUser(id)
  .then( function(user) { ... },
         function(error) { ... } )
----

On peut aussi laisser les erreurs se propager automatiquement au fil de la chaîne de traitement et les récupérer avec la fonction `catch`.

[source,language=javascript]
----
this.userService.getUser(id)
  .then( function(user) { ... } )
  .then( function(rights) { ... } )
  .catch( function(error) { ... } )
----

=== Création d'une `Promise`

- fournir un traitement :

[source,language=javascript]
----
function getUser(id) {
  return new Promise(function(resolve, reject) { <1>
    let request = new XMLHttpRequest(...)
    request.onStateChange = function(...) {
      resolve(data) <2>
      reject('unknown error') <3>
    }
  })
}
----
<1> création de la promesse. L'exécution de la fonction passée en paramètre se produit aussitôt.
<2> résolution de la promesse avec la valeur obtenu après un traitement asynchrone.
<3> rejet de la promesse après erreur dans le traitement asynchrone.

- fournir une promesse réalisée ou rejetée :

[source,language=javascript]
----
let resolvedPromise = Promise.resolve(55) <1>
let rejectedPromise = Promise.reject('description de l erreur') <2>
----
<1> promesse résolue avec la valeur `55`.
<2> promesse rejetée avec l'erreur passée en paramètre.

=== Plus loin avec les `Promise`s

L'API des promesses est plus riche et flexible que le seul aperçu montré ici. Une documentation plus complète est disponible ici : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise.

Combinées avec les _fat arrow functions_ décrites dans le chapitre suivant, les _Promises_ sont très puissantes pour clarifier l'enchainement de traitements asynchrones.

=== _fat arrow functions_

Comme il est extrêmement fréquent d'écrire des fonctions de rappel (_callbacks_), la syntaxe d'ES6 intègre un nouvel élément permettant de déclarer des fonctions de manière plus concise. C'est l'opérateur _fat arrow_ :

[source,language=javascript]
----
let maFonction = (arg1, arg2) => arg1 + arg2 <1>

let autreFonction = (arg1) => { <2>
  ...
  return result
}
----
<1> pas besoin du mot-clé `return` si la valeur retournée est directe.
<2> sinon on déclare un bloc comme d'habitude.

ATTENTION Les fonctions _fat arrow_ présentent un différence notable avec les fonctions traditionnelles : le mot-clé `this` garde sa valeur au moment où la _fat arrow_ function est créée. Aucun `this` particulier n'est attaché aux _fat arrow functions_...

=== `Set` et `Map`

Javascript intègre désormais les structures de données `Set` et `Map`.

=== Interpolation dans les chaines de caractères

L'interpolation de chaines est maintenant facilitée en ES6 grâce aux patrons de chaine :

[source,language=javascript]
----
var description = user.name.toUpperCase() + ' (' + user.id + ')';

// devient

let description = `${user.name.toUpperCase()} (${user.id})`
----

=== Les modules

Plusieurs problèmes :

- tout le monde a besoin de charger des bibliothèques
- différentes bibliothèques de chargement de modules ont vu le jour
- différentes bibliothèques sont apparues en fonction de l'utilisation (front avec _AMD_ ou back avec _CommonJS_)
- le chargement de modules en ES5 fonctionne mais est encombrant et non optimal.

Les nouveaux modules ES6 répondent à ces problèmes et unifient en une seule spécification le chargement de modules dans les mondes serveur et client.

Le chargement des modules (c'est-à-dire des dépendances de votre application) se fait de façon asynchrone en fonction des déclarations de dépendance faites au début du module.

La syntaxe d'importation des modules est stricte de façon à permettre aux outils de développement d'exécuter des analyses perfectionnées.

Les modules ES6 permettent également de définir clairement et facilement les parties d'un module que l'on souhaite _exporter_.

=== Les modules

Exporter une fonction, une variable ou une classe :

[source,language=javascript]
----
export class BookService {
  ...
}

export function ean(value) { ... }
----

Pour importer ces fonctions dans un autre module, on procède ainsi :

[source,language=javascript]
----
import {BookService, ean} from './book_service'

let svc = new BookService()
ean('12355')
----

On peut également donner des alias aux éléments importés :

[source,language=javascript]
----
import {ean as EAN} from './book_service'

let ean = EAN('634')
----

Ou importer tout le module avec :

[source,language=javascript]
----
import * from './book_service'
----

Les modules en ES6 permettent de séparer son code en petites parties, dont la responsabilité est limitée et clairement établie.

Ils facilitent également le travail des usines logicielles.







== Typescript

Nécessité du typage dans les grosses applications maintenues par de grandes équipes.

Typescript est un sur-ensemble de Javascript qui lui ajoute un typage flexible (_duck typing_).

Le compilateur Typescript analyse les fichiers source Typescript et produit des fichiers Javascript exécutables dans n'importe quel navigateur (ou NodeJS pour le serveur).

Participe maintenant à l'élaboration des futures versions d'ECMAScript.

La philosophie de Typescript est d'ajouter dans le code source Javascript des annotations de type permettant au compilateur de garantir l'absence d'erreurs vérifiables par le système de typage.

Typescript est écrit et maintenu par _Microsoft_. C'est un outil open source. Il est le langage préféré lorsqu'on écrit une application _Angular_ (bien qu'il soit aussi possible d'écrire des applications _Angular_ en _Java_, en _Dart_ et en _ES5/6_).

Documentation disponible ici https://www.typescriptlang.org/docs/tutorial.html.

=== Les annotations de type

Le compilateur Typescript propage les informations de typage dont il dispose. Il procède à l'inférence de type au maximum pour vérifier la cohérence du code et fournir aux IDE les informations nécessaires aux fonctionnalités d'_auto-complétion_.

Néanmoins, le compilateur Typescript a besoin d'informations que seul le développeur connaît.

Le typage dans Typescript est complètement débrayable et on se retrouve avec le langage ECMAScript 6.

[source,language=javascript]
----
function greeter(person: string) {
  return "Hello, " + person
}

greeter("Jane")
greeter(42) // COMPILATION ERROR
----

Typescript possède un système de typage complet, comprenant la généricité, les types optionels, etc. Une liste d'objets implémentant l'interface `Utilisateur` est typée :

[source,language=javascript]
----
let list : Array<Utilisateur> = []
----

=== Les types de base

Les types de bases sont :

- les mêmes que ceux de Javascript : `boolean`, `number`, `string`, `Array<>` ou `[]`, `null`, `undefined`.
- Et des types _augmentés_ : les _tuples_, `enum`, `void`, `never`.

Le type `any` décrit des variables dont le type n'est pas connu à l'avance. Lorsqu'une variable est de ce type, le compilateur Typescript désctive la vérification de type dans les expressions qui l'utilisent.

[source,language=javascript]
----
let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
----

=== Assertions de type (_cast_)

Il est possible de _transtyper_ les variables, c'est-à-dire les utiliser comme un autre type que celui qui est inféré par Typescript. Ceci se fait avec l'opérateur d'assertion de type, qui contrairement aux opérateurs `cast` d'autres langages ne réalise aucune opération sur les opérandes.

Il existe deux formes d'assertion de type :

[source,language=javascript]
----
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;

let strLength2: number = (someValue as string).length;
----

=== Interfaces

Les interfaces permettent de décrire les variables que l'on manipule dans un programme. Le langage Typescript utilise le _duck typing_, ce qui signifie que deux types sont considérés équivalents s'ils ont la même forme.

[source,language=javascript]
----
function printLabel(labelledObj: { label: string }) { <1>
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
----
<1> l'interface du paramètre `labelledObj` est décrite comme un objet possédant au moins une propriété `label` de type `string`.

Il est bien sûr possible de nommer les interfaces :

[source,language=javascript]
----
interface Person { <1>
  firstName: string; <2>
  lastName: string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName
}

greeter({ firstName: "Jane", lastName: "User" })
greeter({ firstName: "Toto"}) // COMPILATION ERROR
----
<1> déclaration de l'interface `Person`
<2> description de l'attibut `firstName`. Il est de type `string`

Dans une interface, les propriétés peuvent être _optionnelles_ (mot-clé `?`), en lecture seule (mot-clé `readonly`).

=== Décrire une fonction

Une interface peut aussi décrire les fonctions.

[source,language=javascript]
----
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(src: string, subString: string) { <1>
    let result = src.search(subString);
    return result > -1;
}
----
<1> les annotations de type peuvent être retirées car la variable est de type `SearchFunc` qui les contient déjà.

=== Décrire un objet _indexable_

[source,language=javascript]
----
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
----

=== Implémenter une interface

Les _classes_ Typescript peuvent implémenter des interfaces. Cela permet au compilateur de vérifier que la classe possède bien les méthodes et attributs spécifiés par l'interface, et de générer des erreurs de compilation si ce n'est pas le cas.

[source,language=javascript]
----
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
----

L'héritage fonctionne aussi entre interfaces (une interface peut hériter d'une autre).

=== Types hybrides

En Javascript il est possible de définir toutes sortes d'objets bizarres. Typescript prend cet état de fait en compte et permet de décrire un maximum des possibilités offertes par Javascript.

[source,language=javascript]
----
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
----

Pouvoir décrire des types ainsi permet aussi de décrire le fonctionnement des bibliothèques Javascript que vous intégrez dans vos projet. Ceci permet de les utiliser de façon sure et prouvée par le compilateur !

=== Les génériques

Typescript supporte l'utilisation des types génériques. Cette fonctionnalité permet de décrire un type en fonction d'autres types.

[source,language=javascript]
----
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: <U>(arg: U) => U = identity;
----

Voici un exemple plus avancé de l'utilisation des génériques :

[source,language=javascript]
----
class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function findKeeper<A extends Animal, K> (a: {new(): A;
    prototype: {keeper: K}}): K {

    return a.prototype.keeper;
}

findKeeper(Lion).nametag;  // typechecks!
----

=== Typage avancé

D'autres éléments du système de type de Typescript existent comme :

- les _intersections_,
- les _unions_,
- les _types de protection_ (type guards),
- les types _nullable_,
- les _alias_,
- les _string literals_,
- les unions _discriminées_ (discriminated unions),
- le `this` _polymorphique_,
- _index types_,
- types _mappés_,
...

Voir la page de documentation officielle ici https://www.typescriptlang.org/docs/handbook/advanced-types.html.

=== Décorateurs

Un décorateur est une déclaration qui peut être attachée à une _classe_, une _fonction_, un _accesseur_, une _propriété_ ou un _paramètre_.

Les décorateurs utilisent la forme `@expression`, dans laquelle `expression` est une fonction qui sera appelée avec les les informations sur la déclaration décorée.

Utilisés intensément par Angular pour décrire des méta données sur les composants. En conjonction avec la bibliothèque `reflect-metadata` qui devrait être incessament sous peu intégrée dans le standard Javascript.

Pour plus d'informations, consultez cette page https://www.typescriptlang.org/docs/handbook/decorators.html.

Un décorateur peut avoir la forme
[source,language=javascript]
----
function decorator(target: any, name: string, descriptor: any) {
  logger.log(`call to ${name}`)
  return descriptor
}
----

=== Fichiers de déclaration de type

Il est courant d'utiliser à partir d'un programme Typescript des bibliothèques écrites en Javascript.

Typescript permet de fournir un fichier de déclaration de type qui décrit au compilateur comment la bibliothèque externe fonctionne.

Voici une page avec plus d'information https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html.

Un projet très connu recense un grand nombre de fichiers de déclarations de types pour de nombreuses bibliothèques javascript. Il s'agit du projet _Definitely Typed_.













== Angular

=== Kezaco ?

Angular est un framework RIA orienté composant.

La brique élémentaire d'une application Angular est le composant. Il est responsable d'une partie du DOM. Il peut contenir d'autres composants et donc être contenu par son parent. Le mode de communication entre les différents composants est imposé par Angular. De multiples possibilités sont offertes.

Un composant possède deux facettes :

- la vue (_template_) : du code HTML spécifiant le rendu du composant,
- le modèle : le code Typescript ou Javascript manipulant les données.

Les intéractions entre vue et modèle sont gérées par le framework grâce au _data-binding_. Celui-ci est assuré grâce au mécanisme des _zones_ hérité du monde _Dart_.

Une application est donc un arbre de composants.

Les composants sont regroupés en modules pour former des entités cohérentes traitées par le runtime Angular.

Un module de _bootstrap_ lui-même référençant un composant de _bootstrap_ est utilisé pour le démarrage de l'application. Ensuite le cycle de vie des composants est pris en charge par le framework Angular.

La mise en place des composants dans une application Angular est prise en charge par le mécanisme d'_injection de dépendance_. Angular fournit aux composants les objets nécessaires à leur fonctionnement. Ainsi chaque composant est naturellement aisément testable, et la structure de l'application reste claire.

Angular fournit aussi de nombreuses bibliothèques permettant de faire notamment des requêtes _http_, le _routage_, les _animations_ etc.

Angular offre aussi des outils d'_AOT_ qui consistent à optimiser la phase de compilation pour générer des fichiers javascript les plus légers possible.

=== Exercice

Faire l'exercice de création d'un projet Angular dans les Travaux Pratiques.

=== Gestion d'une appli Angular

Il est possible de configurer un projet Angular entièrement à la main (voir exercice 1 dans Travaux Pratiques).

Angular fournit aussi un outil en ligne de commande pour gérer les différents aspects d'un projet : `angular-cli`.

Description | Commande
===========|============
Création d'un projet | `ng new NOM_PROJET`
Démarrage de l'application | `ng serve`
Créer un nouveau composant | `ng generate component COMPONENT_NAME`
Plugin Github Pages | `ng github-pages:deploy`

== Composant

C'est la brique fondamentale d'une application Angular. Chaque composant de votre application sera une classe décorée avec `@Composant`. Celui-ci reçoit un objet avec des propriétés pour chaque option :

- `selector` : nom de l'élément HTML qui déclenche l'injection du composant dans l'application.
- `template` : la vue du composant, écrite en HTML avec une syntaxe additionnelle spécifique à Angular.

D'autres options sont facultatives:

- `templateUrl` : à utiliser à la place de `template` pour déclarer la vue dans un fichier externe.
- `styles` : un tableau de styles CSS spécifiques au composant.
- `styleUrls` : un tableau de lien vers des feuilles externes.
- `providers` : un tableau de classes fournies en tant que dépendances à sa descendance.

=== Les templates

Une template est la partie _vue_ d'un composant.

Elle s'écrit en HTML avec une syntaxe étendue pour les fonctionnalités d'Angular.

La template d'un composant peut s'écrire dans le fichier du composant lui-même (attribut `template` du décorateur `@Component`).

Elle peut aussi être écrite dans un fichier HTML à part, en précisant le chemin de celui-ci dans l'attribut `templateUrl` du décorateur `@Composant`.

=== Interpolation

Angular permet d'injecter très facilement les données du composant dans sa template.

Exemple :

[source]
----
import {Component} from '@angular/core'

@Component({
    selector: 'angular-app',
    template: '<h1>Hello {{userName}} !</h1>'
})
export class AngularAppComponent {
  userName: string = 'Monsieur Développeur'
}
----

Dans la partie template, l'expression `{{userName}}` demande à Angular d'effectuer l'interpolation de la variable `userName` en utilisant l'instance du composant comme contexte d'évaluation. Le flux HTML inséré dans la page sera donc `<h1>Hello Monsieur Développeur !</h1>`.

=== Interpolation

L'interpolation ne se limite pas à vider le contenu d'une variable dans le flux HTML. On peut accéder aux éléments imbriqués d'un objet, ou encore fournir des expressions dans l'élément d'interpolation `{{ }}`.

[source]
----
import {Component} from '@angular/core'

@Component({
    selector: 'angular-app',
    template: '<h1>Hello {{user?.name}} !</h1>'
})
export class AngularAppComponent {
  user = { id: 5, name: 'Monsieur Développeur' }
}
----

L'expression `{{user?.name}}` utilise l'opérateur de navigation sûr, qui renvoie `null` si la variable `user` vaut `null` (au lieu de provoquer une exception du type "cannot access to property XXX for undefined").

=== Le binding de propriétés DOM

La syntaxe `{{}}` est en fait un raccourci vers la fonctionnalité de _liaison de propriété_.

La syntaxe une fois développée correspond en fait à :

[source,language=html]
----
<p>{{ user.name }}</p>

<p [textContent]="user.name">
----

On se rend compte que la syntaxe d'interpolation ne fait en fait que positionner la valeur de l'attribut DOM `textContent` de notre élément.

Et l'ensemble complet des attributs DOM est accessible avec cette syntaxe `[attributDom]="expression évaluée dans le contexte du composant"`.

Il est par exemple possible de faire :

[source]
----
import {Component} from '@angular/core'

@Component({
    selector: 'angular-app',
    template: `
      <h1 [hidden]="!user">Hello {{user?.name}} !</h1> <1>
      <users-list></users-list>`
})
export class AngularAppComponent {
  user = { id: 5, name: 'Monsieur Développeur' }
}
----
<1> Lie la propriété DOM `hidden` (propriété standard) à la valeur de l'expression `!user` dans le contexte du composant.

Donc, ces deux syntaxes sont équivalentes (notez l'appel de fonction !) :

[source]
----
<users-list users="{{getUsersList()}}"></users-list>
<users-list [users]="getUsersList()"></users-list>
----

=== Evénements

La syntaxe des template permet de définir les liens entre les événements que produit le navigateur et les méthodes de votre composant à déclencher.

Par exemple, pour déclencher la méthode `onButtonClick()` du composant, on écrit :

[source]
----
<button (click)="onButtonClick()">Cliquez-moi !</button>
----

Voilà l'exemple d'un composant plus complet :

[source]
----
import {Component} from '@angular/core'

@Component({
    selector: 'angular-app',
    template: `
      <h1>Hello</h1>
      <button (click)="onButtonClick()">Cliquez-moi !</button>
      <p>{{users.length}}</p>`
})
export class AngularAppComponent {
  users = []

  onButtonClick() {
    this.users.push({})
  }
}
----

Cette syntaxe pour capter les événements fonctionne aussi bien avec :

- les éléments DOM natifs (pour récupérer _click_, _focus_, ...)
- les web composants,
- les composants Angular (les composants peuvent emettre des événements qui peuvent être captés par le composant parent)

L'événement généré est accessible avec la _pseudo-variable_ `$event` :

[source]
----
<button (click)="onButtonClick($event)">Cliquez-moi !</button>
----

La méthode appelée peut ensuite utiliser l'événement :

[source]
----
onButtonClick(event) {
  event.stopPropagation()
  event.preventDefault()
}
----

Angular prend aussi en charge les événements clavier et permet un traitement de pointe :

[source]
----
<textarea (keydown.space)="onSpacePress()">Press space!</textarea>
----

Ici la méthode `onSpacePress` ne sera appelée que lorsque la touche `space` sera actionnée. Ceci fonctionne aussi avec les combinaisons de touches (par exemple `keydown.alt.space`).

=== Variables locales

Il est possible de déclarer des variables au sein d'une template afin de référencer des éléments de cette template. Par exemple :

[source]
----
<input type="text" #monInput> <1>
<p>La valeur de la zone est {{monInput.value}}</p>
----
<1> Crée la variable locale `monInput` de type `HTMLInputElement` référençant le champ de saisie.

=== Directives structurelles

Les directives sont des composants légers ne possédant pas de vue propre. Elles permettent de modifier le comportement d'un élément.

Angular fournit un mécanisme de _directives structurelles_ qui permet de modifier la _structure_ DOM de la vue du composant en fonction des données du composant. Ceci permet entre autre de générer des éléments DOM pour chaque élément dans une liste de votre composant etc...

L'utilisation des directives structurelles est marquée par un astérisque (*) devant le nom de la directive.

=== `NgIf`

Directive permettant d'afficher ou pas une template en fonction de l'évaluation d'une expression.

[source]
----
<div *ngIf="user">
  Bonjour {{user.name}}
</div>
----

=== `NgFor`

La directive `NgFor` permet de répéter une template pour chacun des éléments d'une collection. Voici comment afficher une liste de produits :

[source]
----
<div>
  <h3>Produits</h3>
  <div *ngFor="let produit of produits; let i=index">
    <div>{{produit.nom}}</div>
    <div>{{produit.prix}}</div>
  </div>
</div>
----

L'expression `let i=index` est facultative et on peut alors retirer le point-virgule. Cette expression capte dans la variable locale `i` la variable `index` exportée par la directive `NgFor`.

`NgFor` exporte aussi d'autres variables : `even`, `odd`, `first` et `last`.

=== `NgSwitch`

Cette directive permet d'afficher un template en fonction de la valeur d'une expression en entrée.

[source]
----
<div [ngSwitch]="messageCount">
  <p *ngSwitchCase="0">You have no message</p>
  <p *ngSwitchCase="1">You have a message</p>
  <p *ngSwitchDefault>You have some messages</p>
</div>
----

=== Directives structurelles avancées

La notation `*ngFor` ou `*ngIf` est en réalité un raccourcis vers la syntaxe primitive des templates d'Angular.

Le code suivant :

[source]
----
<div *ngFor="let produit of produits; let i=index">
  <div>{{produit.nom}}</div>
  <div>{{produit.prix}}</div>
</div>
----

Génère ceci :

[source]
----
<template ngFor let-produit [ngForOf]="produits">
  <div>
    <div>{{produit.nom}}</div>
    <div>{{produit.prix}}</div>
  </div>
</template>
----

Les directives structurelles s'appuient en effet sur l'élément HTML `template` pour gérer les modèles à générer.

=== Directives fournies par Angular

Angular fournit quelques directives utiles dans certains cas.

`NgStyle` permet d'affecter plusieurs propriétés CSS en un seul attribut :

[source]
----
<div [ngStyle]="{fontWeight: fontWeight, color: color}">I've got style</div>
----

`NgClass` permet de faire la même chose avec les classes CSS :

[source]
----
<div [ngClass]="{'awesome-div': isAnAwesomeDiv(), 'colored-div': isAColoredDiv()}">I've got style</div>
----

=== Injecter des composants dans les templates

A partir du moment où un composant est déclaré dans le module de l'application ou que celui-ci est importé à partir d'un autre module, on peut demander la création du composant en insérant dans la template une balise dont le nom correspond au _selecteur_ du composant à insérer.

[source]
----
import {Component} from '@angular/core'

// Ce composant doit être déclaré dans notre module (dans la partie `declarations` du décorateur `NgModule`)
@Component({
    selector: 'users-list',
    template: `UNE LISTE D'UTILISATEURS`
})
export class UsersListComponent {
}

@Component({
    selector: 'angular-app',
    template: `
      <h1>Hello {{user?.name}} !</h1>
      <users-list></users-list>`
})
export class AngularAppComponent {
  user = { id: 5, name: 'Monsieur Développeur' }
}
----

=== Résumé

Les templates Angular permettent d'exprimer les vues des composants en HTML standard.

Une syntaxe additionnelle, assez légère permet de spécifier les liaisons entre la vue et les données et comportements du composant. Le mécanisme fourni par Angular est très bien pensé et s'adapte aussi bien aux noeuds HTML standards, aux autres composants Angular et aux _Web Components_.

Interpolation  |  `{{expression}}`
Liaison de propriété  |  `[propriete]`
Liaison d'événement  |  `(evenement)`
Variable locale  |  `#variable`
Directives structurelles  |  `*directive`

== Communication entre composants

La communication entre les différents composants d'une application Angular est clairement définie. Elle permet au mécanisme du _data binding_ de détecter le flots des changements dans les états des composants efficacement.

Quand un composant souhaite recevoir des données provenant de son parent, il déclare des _entrées_.

Quand un composant souhaite emettre des informations à destination de son parent, il déclare des _sorties_.

=== `@Input`

Le décorateur `@Input` est utilisé pour déclarer une entrée dans un composant.

[source]
----
@Component({
  selector: 'produit',
  template: '<div>{{produit | json}}</div>'
})
export class ProduitComponent {
  @Input() produit
}
----

Le parent peut ensuite fournir une valeur à cette entrée en utilisant le mécanisme des templates.

[source]
----
@Component({
  selector: 'produits,
  template: `
<ul>
  <li *ngFor='let p of produits'><produit [produit]='p'></produit></li>
<ul>`
})
export class ProduitsComponent {
  ...
  produits = [{...}, {...}]
}
----

On peut définir un nom d'entrée différent de celui de la propriété à laquelle elle est liée :

[source]
----
@Input('produit') p
----

Et on peut bien sûr mettre à profit les accesseurs ES6 :

[source]
----
@Input() set produits(value) {
  ...
}
----

=== `@Output`

Pour qu'un composant puisse envoyer des informations à son parent, il doit emettre des événements. Cela s'appelle une _sortie_.

A chaque sortie du composant correspond une propriété du type `EventEmitter`. Cet objet est un _Observable_ particulier implémenté pour les besoins d'Angular. Il permet au producteur d'information d'emettre des événements et au consommateur de s'abonner au flux d'événements.

On déclare la sortie dans le composant :

[source]
----
@Component(...)
export class EmailComponent {
  @Output() markedAsRead = new EventEmitter<EMail>() <1>

  onClick() {
    this.markedAsRead.emit(this.email) <2>
  }
}
----
<1> déclaration de la sortie qui est nommée d'après la propriété.
<2> emission d'un événement contenant un référence à l'email du composant.

On consomme l'information ainsi :

[source]
----
@Component({
  template: `
<email *ngFor='let email of emails' (markedAsRead)='doSomething($event)'></email>` <1>
})
export class SommaireComponent {
  doSomething(email) { <2>
    ...
  }
}
----
<1> on s'abonne à la sortie du composant avec la syntaxe standard des templates. Pour passer la donnée de l'événement à la fonction on utilise le mot-clé consacré `$event`.
<2> on reçoit la donnée de l'événement dans la fonction.

== Injection de dépendances

L'injection de dépendance est un patron de conception dans lequel un composant applicatif ne construit pas les composants dont il dépend mais les reçoit de l'extérieur (généralement par le constructeur ou un accesseur).

Ce pattern implique qu'un autre composant est en charge de fournir les dépendances des composants, c'est l'injecteur de dépendances.

Ce pattern améliore la séparation des responsabilités (consommateur et producteur) et facilite la testabilité de chaque composant. Chaque composant "déclare" les composants dont il a besoin.

Le modèle suivi par Angular est le suivant :

- chaque composant possède son propre injecteur de dépendances et peut lui ajouter des services.
- les injecteurs de dépendances sont organisés hiérarchiquement (parent/enfants).
- les composants déclarent les dépendances dont ils ont besoin dans leur constructeur.

=== Injecter un service dans un composant

Le service est la classe qui fournit un service :

[source]
----
@Injectable() <1>
export class DataService {
  produits() {
    return [{id:3, nom:"Livre"}]
  }
}
----
<1> le décorateur `@Injectable` permettra plus tard d'injecter des dépendances dans la classe `DataService`.

Pour la rendre disponible dans l'application entière, nous allons la déclarer dans l'injecteur racine :

[source]
----
@NgModule({
    imports: [BrowserModule],
    declarations: [AngularAppComponent],
    providers: [DataService], <1>
    bootstrap: [AngularAppComponent]
})
export class AppModule {
}
----
<1> ceci enregistre la classe `DataService` dans le panel des classes que peut fournir l'injecteur de dépendances.

Pour demander une instance de cette classe, on procède ainsi :

[source]
----
@Component({...})
export class MonComposant {
  constructor(private DataService dataService) {
  }

  uneMethode() {
    this.dataService.getData()
  }
}
----

Une seule instance par injecteur est créée, pour chaque classe fournie. Les injecteurs étant organisés en hiérarchie, la recherche des dépendances se fait en remontant l'arbre des injecteurs.

Un injecteur enregistre les dépendances qu'il sait résoudre en relation avec leur _clé_.

Les composants aussi peuvent enregistrer des classes dans leur injecteur de dépendances. Ceci se fait avec l'attribut `providers` du décorateur `@Composant` :

[source]
----
@Component({
  providers: [AutreService] <1>
})
export class MonComposant {
}
----
<1> ici le composant `MonComposant` ajoute à son injecteur la classe `AutreService`. Celle-ci sera donc disponible dans les composants fils de celui-ci.

=== Injection paramétrée

Le moteur d'injection de dépendances d'Angular permet sa configuration.

La configuration précédente aurait pu être écrite dans sa forme complète :

[source]
----
providers: [
  {provide: DataService, useClass: DataService} <1>
]
----
<1> `provide` désigne le _token_ et `useClass` est le service fourni.

Une seule instance du service est créée par token.

Si on veut demander l'injection d'une autre classe pour le même token, on peut écrire :

[source]
----
providers: [
  {provide: DataService, useClass: MockDataService} <1>
]
----
<1> le service mocké est utilisé pour les tests.

=== Injection de valeurs

Les injecteurs de dépendances peuvent aussi injecter des valeurs ou n'importe quel autre objet javascript. Comme dans ce cas, la clé de dépendance n'est pas une classe, il faut utiliser un `OpaqueToken` :

[source]
----
// Dans un fichier à part

import { OpaqueToken } from '@angular/core'

export let APP_CONFIG = new OpaqueToken('app.config');

// Dans un module ou un composant on enregistre le fournisseur :

providers: [
  {provide:APP_CONFIG, useValue:{production: false, title: 'Sandrero'}}
]
----

On peut ensuite demander la fourniture de la dépendance :

[source]
----
@Component(...)
export class AngularAppComponent {
    constructor( @Inject(APP_CONFIG) private config: { production; title; }) {
    }
}
----

=== Injection avec alias

Il est possible de réutiliser une instance fournie même si sa classe est déjà enregistrée avec une autre clé. Ceci est fait avec la propriété `useExisting`.

[source]
----
[ NewLogger,
  // Alias OldLogger w/ reference to NewLogger
  { provide: OldLogger, useExisting: NewLogger}
]
----

=== Injection avec fabrique

Si on veut soit même décider de la classe à fournir dynamiquement, il est possible de donner à l'injecteur une fonction _fabrique_ (_factory_) dont le rôle est de créer la dépendance.

[source]
----
const IS_PROD = true;

// dans le module
providers: [
  LogService,
  {
    // clé du service fourni
    provide: DataService,
    
    // dépendances nécessaires pour la création du service DataService
    deps: [LogService],

    // la fonction factory reçoit les dépendances déclarées dans `deps` afin de pouvoir initialiser
    // le service qu'elle produit.
    useFactory: logService => IS_PROD ? new DataService(logService) : new MockDataService(logService)
  }
]
----

=== Les directives

Une directive ajoute un comportement aux éléments du DOM. Elle est attachée à volonté sur les éléments des templates. Plusieurs directives différentes peuvent être attachées au même élément DOM.

Le décorateur correspondant est `@Directive`.

Les directives possèdent un _sélecteur_ qui permet à Angular de savoir quand l'activer. C'est la même syntaxe que les sélecteurs CSS (`div`, `.info`, `[state]`, `.info:not(.urgent)`, ...) avec quelques interdictions.

La directive est la classe mère des composants, ceux-ci en hérite de toutes les fonctionnalités.

[source]
----
@Directive( selector = "[myHighlight]" )
export class HighlightDirective
{
	defaultColor = "red"
	highlightColor = null

	constructor(private elementRef: ElementRef, private renderer: Renderer) {
	}
	
  @Input() set highlightColor(color) {
		this.highlightColor = color
	}

	@Input() set defaultColor(colorName) {
		this.defaultColor = this.colorName ? this.colorName : this.defaultColor
	}

	@HostListener() mouseenter() {
		this.highlight(this.highlightColor ? this.highlightColor : this.defaultColor)
	}

	@HostListener() mouseleave() {
		this.highlight(null)
	}

	private highlight(String color) {
		this.renderer.setElementStyle(this.elementRef.nativeElement(), "backgroundColor", color)
	}
}
----



== Pipes

Un _pipe_ permet de transformer les informations à afficher dans la vue au sein d'une template.

Quelques pipes sont fournies par Angular :

`json` affiche la donnée en format _JSON_.

[source]
----
<div>{{ users | json }}</div>
----

`slice` permet d'extraire une partie d'une collection ou d'une chaine de caractères.

[source]
----
<div>{{ users | slice:0:2 | json }}</div>
----

`uppercase` et `lowercase` changent la casse des chaines de caractères.

`number` permet de formatter un nombre, avec le format des paramètres suivants : `{integerDigits}.{minFractionDigits}-{maxFractionDigits}`.

[source]
----
<p>{{ 5.13 | number:'.1-1' }}</p>
<!-- affichera '5.1' -->
----

`percent` affiche un pourcentage.

`currency` affiche une devise.

`date` formatte une date.

`async` permet d'attendre l'arrivée des données d'une `Promise` ou d'un `Observable`.

[source]
----
@Component({
  selector: 'test-async',
  template: `<div>{{ promesse | async }}</div>`
})
export class TestAsyncComponent {
  promesse = new Promise(resolve => {
    window.setTimeout(() => resolve('BONJOUR!'), 1000);
  });
}
----

=== Création d'une pipe

Il est bien sûr possible d'implémenter ses propres pipes.

[source]
----
import { PipeTransform, Pipe } from '@angular/core';

@Pipe({name: 'fromNow'})
export class FromNowPipe implements PipeTransform {
  transform(value, args) {
    // do something here
  }
}
----

Une fois déclarée dans le module, elle est utilisable dans les template avec le mot-clé `formNow`.

== Services du framework

=== Title

=== Http

== Tests

=== Tests unitaires

Avec _Jasmine_.

== Style des compodants et encapsulation

== Cycle de vie des composants et hooks

== Créer un composant par programmation

== RxJs

== Programme

* Jour 1
Installation / introduction
Philosophie du framework
Installation minimale
Ecosystème
TypeScript et ES2015, Modules ES6
Types
Classes
Modules
-- déclaration d'un module : imports et exports
-- lazy loading des modules avec le router
-- les providers d'un module
Promesses
Décorateurs
Outils
Composants
Définition
Décorateur
Vue
Contrôleur
Composants natifs
Cycle de vie
Directives : structurelles et d'attribut
IOC : injection de dépendances : par type et hiérarchique
Providers

* Jour 2
Pipes
Pipes natifs
Écrire un pipe
Formulaires
-- créer un formulaire
-- validation et erreurs
-- template-driven forms
-- model-driven forms
-- formulaires dynamiques
-- créer ses propres validateurs
-- Control et ControlGroup
-- FormBuilder
Contrôles
Validateurs
Observateurs
ngModel
Reactive Programming
Concept
RxJS : introduction
-- Observables
-- principes des opérations sur les Observables
-- ReactiveX avec RxJS
-- lien avec les promesses
Services
Créer un service
Injection de service
Template : interpolation/expression, "Binding" et filtres.
Directives de transformation : ngIf, ngFor, ngSwitch...
Evènements utilisateur.

* Jour 3
Service HTTP
Communication avec une API
-- requetes HTTP vers un serveur
-- WebSockets
Options
Routeur
-- `router-outlet`
-- configuration des routes et URLs
-- définition des routes, liens et redirections, paramètres
-- hiérarchie des routes
-- vues imbriquées
-- Cycle de vie du routage
-- Route guards
Principe
Composant de route
Paramètres
Routes imbriqués
Tests : Karma et Jasmine
Tests asynchrones
Tests end-to-end avec protractor
Injection de dépendance
Recettes de tests
Concepts avancés
Webworkers
Rendus alternatifs
Injection de dépendance avancée
Animations
Web Components
Authentification
-- faire des requêtes HTTP, recevoir ou envoyer des données au format JSON

Rendu côté serveur
Rendu dans les Web Workers
Application mobile

Zones
Directives avancées
Injection de dépendances avancée

OPTIONNELS (5 jours)

Animations : états, transitions et animations avec le routeur
Material design
Bibliothèques de Composants
Server-side rendering avec Angular Universal
Compilation statique des templates (AOT)

== Objectifs

● Découvrir les fonctionnalités du framework Angular2
● Savoir développer une nouvelle application Web de façon autonome
● Savoir concevoir une application Angular2 avec JavaScript et TypeScript
● Connaître les mécanismes avancés du framework
Savoir commmuniquer avec un serveur
Savoir tester son application
Connaître les bonnes pratiques de développement


Théorique

Pratique : TP pour être sur d'avoir compris chaque point.


Liste des exercices NinjaSquad : https://angular-exercises.ninja-squad.com/





== Forms

DOCUMENTATION OFFICIELLE

Form by template https://angular.io/docs/ts/latest/guide/forms.html

NgForm directive API https://angular.io/docs/ts/latest/api/forms/index/NgForm-directive.html

Form reactive (code-driven) https://angular.io/docs/ts/latest/guide/reactive-forms.html

Form validation https://angular.io/docs/ts/latest/cookbook/form-validation.html

