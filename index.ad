= Angular 2
:author: Arnaud Tournier - @ltearno - LTE Consulting - 2017 - Toulouse
:email: ltearno@gmail.com
:backend: revealjs
:imagesdir: images
:revealjs_theme: white
:revealjs_history: true
:source-highlighter: highlightjs
:revealjs_width: 1600
:revealjs_height: 1200
:revealjs_hideaddressbar: true
:revealjs_mousewheel: true
:revealjs_slidenumber: true
:revealjs_transitionspeed: fast
:revealjs_fragments: true
////
:source-highlighter: coderay
:revealjs_transition: zoom
:source-highlighter: pygments
////

== Arnaud Tournier

Email: ltearno@gmail.com

Twitter: https://twitter.com/ltearno[@ltearno]

Web: http://www.lteconsulting.fr[www.lteconsulting.fr]

== ECMASCRIPT 6

Spécification standardisée du Javascript : ECMAScript.

La version 5 est la plus largement répandue aujourd'hui.

La version suivante est ECMAScript 6 (ou ES6, ou ECMASCRIPT 2015). Elle propose de nombreuses fonctionnalités comme les _classes_, les _constantes_, les _arrow functions_, les _générateurs_...

Angular se base sur cette version d'ECMAScript, bien qu'une API existe pour écrire des applications en ECMAScript 5.

Les navigateurs modernes sont déjà à jour pour cette version. Il existe des transpileurs (Babeljs, Traceur par exemple) pour générer du code ECMAScript 5 à partir de code en version 6.

Nous allons découvrir les nouveautés d'ECMAScript à connaître impérativement pour avoir une expérience de développement optimale avec Angular.

Ces nouveautés permettent en général soit de corriger un défaut du langage javascript, soit d'amener un _sucre syntaxique_ permettant d'exprimer des constructions issues des languages _POO_. D'autres améliorations permettent tout simplement d'être plus efficace dans son développement. Enfin, l'ensemble des améliorations permet un meilleur traitement des sources dans les environnements de développement (IDE).

=== `;` optionnel

Le point-virgule `;` est désormais optionnel dans les sources Javascript.

Sauf rares cas, il est pratiquement possible de purement et simplement les supprimer de vos sources.

=== `let`

[source,language=javascript]
----
let maVariable = 5
----

Le mot-clé `let` corrige les défauts de `var` utilisé pour déclarer des variables en Javascript, notamment :

- la portée des variable. Les variables `let` ont une durée de vie limitée au bloc dans lequel elles se trouvent. Et non à la _fonction_ dans laquelle elles se trouvent.
- le _hoisting_. Les variables `let` ne sont pas accessibles avant la ligne qui les déclare.

La déclaration de variable en Javascript se comporte enfin de la manière attendue !

=== `const`

[source,language=javascript]
----
const maConstante = 53

// provoque une erreur :
maConstante = 42
----

Le mot-clé `const` permet de déclarer une constante, c'est à dire une variable dont on ne peut pas changer la valeur.

C'est une fonctionnalité de language qui manquait à Javascript.

=== Construction rapide d'objets

Une nouvelle forme de syntaxe pour créer des objets rapidement :

[source,language=javascript]
----
function creerUser( nom, prenom ) {
  return {
    nom, <1>
    prenom
  }
}
----
<1> La propriété de l'objet aura le même nom que la variable utilisée comme valeur

est équivalent à :

[source,language=javascript]
----
function creerUser( nom, prenom ) {
  return {
    nom: nom,
    prenom: prenom
  }
}
----

=== Affectations destructurées

Nouvelle syntaxe qui permet de facilement affecter des variables à partir de propriétés d'objets ou d'éléments de tableaux.

En ES5, pour extraire des variables à partir d'un objet, on écrit souvent :

[source,language=javascript]
----
// en entrée un objet data = { id: 3, name: 'toto' }
var id = data.id;
var name = data.name;
----

L'affectation destructurée permet ceci :

[source,language=javascript]
----
let { id, name } = data <1>
----
<1> L'affectation destructurée déclare et initialise les variables `id` et `name`.

Si on souhaite affecter des variables avec des noms différents des propriétés de l'objet, on peut faire ainsi :

[source,language=javascript]
----
let { id: userId, name: userName } = data <1>
----
<1> L'affectation destructurée déclare et initialise les variables `userId` et `userName`.

Ceci fonctionne aussi avec les objets imbriqués :

[source,language=javascript]
----
let { id: userId, address: { street: userStreet } } = data
----

Cette syntaxe fonctionne aussi avec les tableaux :

[source,language=javascript]
----
// avec un tableau t = [3, 6, 4, 7]

let [ premier, deuxieme ] = t
----

=== L'opérateur de reste

Cet opérateur permet d'accepter facilement un nombre de paramètres variable dans une fonction :

[source,language=javascript]
----
function ajouterProduits( ...produits ) {
  for(let produit of produits) {
    ...
  }
}
----

On peut aussi utiliser cet opérateur avec les affectations destructurées :

[source,language=javascript]
----
let [head, ...tail] = list <1>
----
<1> `head` contient le premier élément et `tail` la suite de la liste

=== L'opérateur d'étalement

C'est le complémentaire de l'opérateur de reste. Il permet de _convertir_ un tableau en liste d'arguments :

[source,language=javascript]
----
let coordonnees = [12, 32]
let point = new Point(...coordonnees)
----

=== Valeurs par défaut

Il est maintenant possible de donner des valeurs par défaut aux paramètres de fonctions et éléments d'affectation destructurée.

Au lieu d'écrire :

[source,language=javascript]
----
function faireChose( size, value ) {
  value = value || 0 // valeur par défaut
}
----

On préfèrera :

[source,language=javascript]
----
function faireChose( size, value = 0 ) {
}
----

La valeur par défaut peut aussi être un appel de fonction, ou même une expression faisant référence à d'autres paramètres de la fonction (_quand ils sont à gauche de là où on les utilise_). Voyez cet exemple :

[source,language=javascript]
----
function autreChose( factory = defaultFactory(), type = factory.type ) { <1>
}
----
<1> la fonction `defaultFactory` ne sera appelée que lorsque l'appelant ne fournit pas de valeur au paramètre. Si le deuxième paramètre n'est pas fourni, sa valeur sera affectée à l'expression `factory.type`.

Utilisée avec l'affectation destructurée des variables, cette construction s'écrit :

[source,language=javascript]
----
const { timeout = 1000 } = httpOptions
----

=== Les classes

L'introduction des classes en Javascript se fait par l'ajout d'une syntaxe équivalente à un _sucre syntaxique_ pour le moteur d'exécution JS. En effet javascript repose sur un modèle d'héritage par prototype qui permet de simuler l'héritage de classes.

Voici un exemple de classe :

[source,language=javascript]
----
class Livre {
  constructor(private titre) { <1> <2>
  }
  
  description() {
    return `Livre: ${this.titre}`
  }

  static fonctionStatique(toto) {
    return toto
  }
}

let livre = new Livre('Les frameworks JS')

----
<1> la fonction spéciale `constructor` est appelée lorsque l'objet est créé.
<2> l'utilisation de `private` ou `public` crée automatiquement un attribut dans la classe (Typescript seulement ?).

=== Accesseurs

Une classe peut fournir des fonctions _getter_ et/ou _setter_ en plus des attributs classiques.

[source,language=javascript]
----
class EditionService {
  get description() { <1>
    return `service ${this.name}`
  }

  private value

  set longueur(value) { <2>
    if(value.charAt(value.length-1)=='k')
      this._value = value * 1000
    else
      this.value = value
  }
}

let service = new EditionService()

console.log(service.description)

service.longueur = '100k'
service.longueur = 24
----
<1> le mot-clé `get` permet de déclarer un accesseur _getter_ pour la propriété `description`.
<2> le mot-clé `set` permet de déclarer un accesseur _setter_ pour la propriété `longueur`.

=== Héritage

L'héritage de classe est possible avec le mot-clé `extends` :

[source,language=javascript]
----
class Animal {
  constructor(private name) {}
}

class Mamifere extends Animal {
  constructor() {
    super('baleine') <1>
  }

  affiche() {
    console.log('je suis une baleine')

    super.affiche() <2>
  }
}
----
<1> le mot-clé `super` permet de faire référence au constructeur de la classe parente.
<2> le mot-clé `super` permet de faire référence à l'implémentation de la fonction dans la classe parente.

=== Les promises

Avec les versions précédentes de Javascript et l'utilisation intensive des traitements asynchrones, de nombreuses bibliothèques de _promises_ ont vu le jour ces dernières années. Avec même la création de certains standards _de-facto_.

ES5 apporte une normalisation de la gestion des traitements asynchrones avec les _Promises_. Cette API permet d'éviter le _callback hell_.

Une _promise_ est un objet qui représente la mise à disposition d'un résultat _plus tard_ dans le temps. On peut dire qu'il s'agit de la représentation d'un traitement asynchrone.

On peut chainer les traitements asynchrones grâce à la fonction `then` des `Promise`.

[source,language=javascript]
----
this.userService.getUser(id) <1>
  .then( function(user) { return this.userService.getRights() } ) <2>
  .then( function(rights) { this.doSomething(rights) } ) <3>
----
<1> la fonction `getUser()` retourne une `Promise`.
<2> l'appel à la fonction `then` permet de spécifier la fonction qui sera appelée quand la première promesse aura fourni son résultat. Le traitement suivant est retourné, c'est-à-dire la promesse retournée par la fonction `getRights()`. Une valeur aurait pu être directement retournée.
<3> on peut chaîner les appels à `then` pour faire des traitements successifs. Chaque fonction de rappel reçoit le résultat du traitement précédent. Ici aucune valeur n'est retournée pour le potentiel prochain traitement.

=== Les promises

Une promesse peut être dans un des trois états suivants : _pending_, _fulfilled_ ou _rejected_.

Lorsqu'une promesse est rejetée, on peut récupérer l'erreur en passant une fonction de rappel en deuxième paramètre de `then`.

[source,language=javascript]
----
this.userService.getUser(id)
  .then( function(user) { ... },
         function(error) { ... } )
----

On peut aussi laisser les erreurs se propager automatiquement au fil de la chaîne de traitement et les récupérer avec la fonction `catch`.

[source,language=javascript]
----
this.userService.getUser(id)
  .then( function(user) { ... } )
  .then( function(rights) { ... } )
  .catch( function(error) { ... } )
----

=== Création d'une `Promise`

- fournir un traitement :

[source,language=javascript]
----
function getUser(id) {
  return new Promise(function(resolve, reject) { <1>
    let request = new XMLHttpRequest(...)
    request.onStateChange = function(...) {
      resolve(data) <2>
      reject('unknown error') <3>
    }
  })
}
----
<1> création de la promesse. L'exécution de la fonction passée en paramètre se produit aussitôt.
<2> résolution de la promesse avec la valeur obtenu après un traitement asynchrone.
<3> rejet de la promesse après erreur dans le traitement asynchrone.

- fournir une promesse réalisée ou rejetée :

[source,language=javascript]
----
let resolvedPromise = Promise.resolve(55) <1>
let rejectedPromise = Promise.reject('description de l erreur') <2>
----
<1> promesse résolue avec la valeur `55`.
<2> promesse rejetée avec l'erreur passée en paramètre.

=== Plus loin avec les `Promise`s

L'API des promesses est plus riche et flexible que le seul aperçu montré ici. Une documentation plus complète est disponible ici : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise.

Combinées avec les _fat arrow functions_ décrites dans le chapitre suivant, les _Promises_ sont très puissantes pour clarifier l'enchainement de traitements asynchrones.

=== _fat arrow functions_

Comme il est extrêmement fréquent d'écrire des fonctions de rappel (_callbacks_), la syntaxe d'ES6 intègre un nouvel élément permettant de déclarer des fonctions de manière plus concise. C'est l'opérateur _fat arrow_ :

[source,language=javascript]
----
let maFonction = (arg1, arg2) => arg1 + arg2 <1>

let autreFonction = (arg1) => { <2>
  ...
  return result
}
----
<1> pas besoin du mot-clé `return` si la valeur retournée est directe.
<2> sinon on déclare un bloc comme d'habitude.

ATTENTION Les fonctions _fat arrow_ présentent un différence notable avec les fonctions traditionnelles : le mot-clé `this` garde sa valeur au moment où la _fat arrow_ function est créée. Aucun `this` particulier n'est attaché aux _fat arrow functions_...

=== `Set` et `Map`

Javascript intègre désormais les structures de données `Set` et `Map`.

=== Interpolation dans les chaines de caractères

L'interpolation de chaines est maintenant facilitée en ES6 grâce aux patrons de chaine :

[source,language=javascript]
----
var description = user.name.toUpperCase() + ' (' + user.id + ')';

// devient

let description = `${user.name.toUpperCase()} (${user.id})`
----

=== Les modules

Plusieurs problèmes :

- tout le monde a besoin de charger des bibliothèques
- différentes bibliothèques de chargement de modules ont vu le jour
- différentes bibliothèques sont apparues en fonction de l'utilisation (front avec _AMD_ ou back avec _CommonJS_)
- le chargement de modules en ES5 fonctionne mais est encombrant et non optimal.

Les nouveaux modules ES6 répondent à ces problèmes et unifient en une seule spécification le chargement de modules dans les mondes serveur et client.

Le chargement des modules (c'est-à-dire des dépendances de votre application) se fait de façon asynchrone en fonction des déclarations de dépendance faites au début du module.

La syntaxe d'importation des modules est stricte de façon à permettre aux outils de développement d'exécuter des analyses perfectionnées.

Les modules ES6 permettent également de définir clairement et facilement les parties d'un module que l'on souhaite _exporter_.

=== Les modules

Exporter une fonction, une variable ou une classe :

[source,language=javascript]
----
export class BookService {
  ...
}

export function ean(value) { ... }
----

Pour importer ces fonctions dans un autre module, on procède ainsi :

[source,language=javascript]
----
import {BookService, ean} from './book_service'

let svc = new BookService()
ean('12355')
----

On peut également donner des alias aux éléments importés :

[source,language=javascript]
----
import {ean as EAN} from './book_service'

let ean = EAN('634')
----

Ou importer tout le module avec :

[source,language=javascript]
----
import * from './book_service'
----

Les modules en ES6 permettent de séparer son code en petites parties, dont la responsabilité est limitée et clairement établie.

Ils facilitent également le travail des usines logicielles.







== Typescript

Nécessité du typage dans les grosses applications maintenues par de grandes équipes.

Typescript est un sur-ensemble de Javascript qui lui ajoute un typage flexible (_duck typing_).

Le compilateur Typescript analyse les fichiers source Typescript et produit des fichiers Javascript exécutables dans n'importe quel navigateur (ou NodeJS pour le serveur).

Participe maintenant à l'élaboration des futures versions d'ECMAScript.

La philosophie de Typescript est d'ajouter dans le code source Javascript des annotations de type permettant au compilateur de garantir l'absence d'erreurs vérifiables par le système de typage.

Typescript est écrit et maintenu par _Microsoft_. C'est un outil open source. Il est le langage préféré lorsqu'on écrit une application _Angular_ (bien qu'il soit aussi possible d'écrire des applications _Angular_ en _Java_, en _Dart_ et en _ES5/6_).

Documentation disponible ici https://www.typescriptlang.org/docs/tutorial.html.

=== Les annotations de type

Le compilateur Typescript propage les informations de typage dont il dispose. Il procède à l'inférence de type au maximum pour vérifier la cohérence du code et fournir aux IDE les informations nécessaires aux fonctionnalités d'_auto-complétion_.

Néanmoins, le compilateur Typescript a besoin d'informations que seul le développeur connaît.

Le typage dans Typescript est complètement débrayable et on se retrouve avec le langage ECMAScript 6.

[source,language=javascript]
----
function greeter(person: string) {
  return "Hello, " + person
}

greeter("Jane")
greeter(42) // COMPILATION ERROR
----

Typescript possède un système de typage complet, comprenant la généricité, les types optionels, etc. Une liste d'objets implémentant l'interface `Utilisateur` est typée :

[source,language=javascript]
----
let list : Array<Utilisateur> = []
----

=== Les types de base

Les types de bases sont :

- les mêmes que ceux de Javascript : `boolean`, `number`, `string`, `Array<>` ou `[]`, `null`, `undefined`.
- Et des types _augmentés_ : les _tuples_, `enum`, `void`, `never`.

Le type `any` décrit des variables dont le type n'est pas connu à l'avance. Lorsqu'une variable est de ce type, le compilateur Typescript désctive la vérification de type dans les expressions qui l'utilisent.

[source,language=javascript]
----
let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
----

=== Assertions de type (_cast_)

Il est possible de _transtyper_ les variables, c'est-à-dire les utiliser comme un autre type que celui qui est inféré par Typescript. Ceci se fait avec l'opérateur d'assertion de type, qui contrairement aux opérateurs `cast` d'autres langages ne réalise aucune opération sur les opérandes.

Il existe deux formes d'assertion de type :

[source,language=javascript]
----
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;

let strLength2: number = (someValue as string).length;
----

=== Interfaces

Les interfaces permettent de décrire les variables que l'on manipule dans un programme. Le langage Typescript utilise le _duck typing_, ce qui signifie que deux types sont considérés équivalents s'ils ont la même forme.

[source,language=javascript]
----
function printLabel(labelledObj: { label: string }) { <1>
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
----
<1> l'interface du paramètre `labelledObj` est décrite comme un objet possédant au moins une propriété `label` de type `string`.

Il est bien sûr possible de nommer les interfaces :

[source,language=javascript]
----
interface Person { <1>
  firstName: string; <2>
  lastName: string;
}

function greeter(person: Person) {
  return "Hello, " + person.firstName + " " + person.lastName
}

greeter({ firstName: "Jane", lastName: "User" })
greeter({ firstName: "Toto"}) // COMPILATION ERROR
----
<1> déclaration de l'interface `Person`
<2> description de l'attibut `firstName`. Il est de type `string`

Dans une interface, les propriétés peuvent être _optionnelles_ (mot-clé `?`), en lecture seule (mot-clé `readonly`).

=== Décrire une fonction

Une interface peut aussi décrire les fonctions.

[source,language=javascript]
----
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(src: string, subString: string) { <1>
    let result = src.search(subString);
    return result > -1;
}
----
<1> les annotations de type peuvent être retirées car la variable est de type `SearchFunc` qui les contient déjà.

=== Décrire un objet _indexable_

[source,language=javascript]
----
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
----

=== Implémenter une interface

Les _classes_ Typescript peuvent implémenter des interfaces. Cela permet au compilateur de vérifier que la classe possède bien les méthodes et attributs spécifiés par l'interface, et de générer des erreurs de compilation si ce n'est pas le cas.

[source,language=javascript]
----
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
----

L'héritage fonctionne aussi entre interfaces (une interface peut hériter d'une autre).

=== Types hybrides

En Javascript il est possible de définir toutes sortes d'objets bizarres. Typescript prend cet état de fait en compte et permet de décrire un maximum des possibilités offertes par Javascript.

[source,language=javascript]
----
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
----

Pouvoir décrire des types ainsi permet aussi de décrire le fonctionnement des bibliothèques Javascript que vous intégrez dans vos projet. Ceci permet de les utiliser de façon sure et prouvée par le compilateur !

=== Les génériques

Typescript supporte l'utilisation des types génériques. Cette fonctionnalité permet de décrire un type en fonction d'autres types.

[source,language=javascript]
----
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: <U>(arg: U) => U = identity;
----

Voici un exemple plus avancé de l'utilisation des génériques :

[source,language=javascript]
----
class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function findKeeper<A extends Animal, K> (a: {new(): A;
    prototype: {keeper: K}}): K {

    return a.prototype.keeper;
}

findKeeper(Lion).nametag;  // typechecks!
----

=== Typage avancé

D'autres éléments du système de type de Typescript existent comme :

- les _intersections_,
- les _unions_,
- les _types de protection_ (type guards),
- les types _nullable_,
- les _alias_,
- les _string literals_,
- les unions _discriminées_ (discriminated unions),
- le `this` _polymorphique_,
- _index types_,
- types _mappés_,
...

Voir la page de documentation officielle ici https://www.typescriptlang.org/docs/handbook/advanced-types.html.

=== Décorateurs

Un décorateur est une déclaration qui peut être attachée à une _classe_, une _fonction_, un _accesseur_, une _propriété_ ou un _paramètre_.

Les décorateurs utilisent la forme `@expression`, dans laquelle `expression` est une fonction qui sera appelée avec les les informations sur la déclaration décorée.

Utilisés intensément par Angular pour décrire des méta données sur les composants. En conjonction avec la bibliothèque `reflect-metadata` qui devrait être incessament sous peu intégrée dans le standard Javascript.

Pour plus d'informations, consultez cette page https://www.typescriptlang.org/docs/handbook/decorators.html.

Un décorateur peut avoir la forme
[source,language=javascript]
----
function decorator(target: any, name: string, descriptor: any) {
  logger.log(`call to ${name}`)
  return descriptor
}
----

=== Fichiers de déclaration de type

Il est courant d'utiliser à partir d'un programme Typescript des bibliothèques écrites en Javascript.

Typescript permet de fournir un fichier de déclaration de type qui décrit au compilateur comment la bibliothèque externe fonctionne.

Voici une page avec plus d'information https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html.

Un projet très connu recense un grand nombre de fichiers de déclarations de types pour de nombreuses bibliothèques javascript. Il s'agit du projet _Definitely Typed_.













== Angular

=== Kezaco ?

Angular est un framework RIA orienté composant.

La brique élémentaire d'une application Angular est le composant. Il est responsable d'une partie du DOM. Il peut contenir d'autres composants et donc être contenu par son parent. Le mode de communication entre les différents composants est imposé par Angular. De multiples possibilités sont offertes.

Un composant possède deux facettes :

- la vue (_template_) : du code HTML spécifiant le rendu du composant,
- le modèle : le code Typescript ou Javascript manipulant les données.

Les intéractions entre vue et modèle sont gérées par le framework grâce au _data-binding_. Celui-ci est assuré grâce au mécanisme des _zones_ hérité du monde _Dart_.

Une application est donc un arbre de composants.

Les composants sont regroupés en modules pour former des entités cohérentes traitées par le runtime Angular.

La mise en place des composants dans une application Angular est prise en charge par le mécanisme d'_injection de dépendance_. Angular fournit aux composants les objets nécessaires à leur fonctionnement. Ainsi chaque composant est naturellement aisément testable, et la structure de l'application reste claire.

Angular fournit aussi de nombreuses bibliothèques permettant de faire notamment des requêtes _http_, le _routage_, les _animations_ etc.

Angular offre aussi des outils d'_AOT_ qui consistent à optimiser la phase de compilation pour générer des fichiers javascript les plus légers possible.

=== Exercice

Faire l'exercice de création d'un projet Angular dans les Travaux Pratiques.

=== Gestion d'une appli Angular

Il est possible de configurer un projet Angular entièrement à la main (voir exercice 1 dans Travaux Pratiques).

Angular fournit aussi un outil en ligne de commande pour gérer les différents aspects d'un projet : `angular-cli`.

Description | Commande
===========|============
Création d'un projet | `ng new NOM_PROJET`
Démarrage de l'application | `ng serve`
Créer un nouveau composant | `ng generate component COMPONENT_NAME`
Plugin Github Pages | `ng github-pages:deploy`

== Les templates

Une template est la partie _vue_ d'un composant.

Elle s'écrit en HTML avec une syntaxe étendue pour les fonctionnalités d'Angular.

La template d'un composant peut s'écrire dans le fichier du composant lui-même (attribut `template` du décorateur `@Component`).

Elle peut aussi être écrite dans un fichier HTML à part, en précisant le chemin de celui-ci dans l'attribut `templateUrl` du décorateur `@Composant`.

=== Interpolation

Angular permet d'injecter très facilement des données du composant dans sa template.

Exemple :

[source]
----
import {Component} from '@angular/core'

@Component({
    selector: 'angular-app',
    template: '<h1>Hello {{userName}} !</h1>'
})
export class AngularAppComponent {
  userName: string = 'Monsieur Développeur'
}
----

== Programme

* Jour 1
Installation / introduction
Philosophie du framework
Installation minimale
Ecosystème
TypeScript et ES2015, Modules ES6
Types
Classes
Modules
-- déclaration d'un module : imports et exports
-- lazy loading des modules avec le router
-- les providers d'un module
Promesses
Décorateurs
Outils
Composants
Définition
Décorateur
Vue
Contrôleur
Composants natifs
Cycle de vie
Directives : structurelles et d'attribut
IOC : injection de dépendances : par type et hiérarchique
Providers

* Jour 2
Pipes
Pipes natifs
Écrire un pipe
Formulaires
-- créer un formulaire
-- validation et erreurs
-- template-driven forms
-- model-driven forms
-- formulaires dynamiques
-- créer ses propres validateurs
-- Control et ControlGroup
-- FormBuilder
Contrôles
Validateurs
Observateurs
ngModel
Reactive Programming
Concept
RxJS : introduction
-- Observables
-- principes des opérations sur les Observables
-- ReactiveX avec RxJS
-- lien avec les promesses
Services
Créer un service
Injection de service
Template : interpolation/expression, "Binding" et filtres.
Directives de transformation : ngIf, ngFor, ngSwitch...
Evènements utilisateur.

* Jour 3
Service HTTP
Communication avec une API
-- requetes HTTP vers un serveur
-- WebSockets
Options
Routeur
-- `router-outlet`
-- configuration des routes et URLs
-- définition des routes, liens et redirections, paramètres
-- hiérarchie des routes
-- vues imbriquées
-- Cycle de vie du routage
-- Route guards
Principe
Composant de route
Paramètres
Routes imbriqués
Tests : Karma et Jasmine
Tests asynchrones
Tests end-to-end avec protractor
Injection de dépendance
Recettes de tests
Concepts avancés
Webworkers
Rendus alternatifs
Injection de dépendance avancée
Animations
Web Components
Authentification
-- faire des requêtes HTTP, recevoir ou envoyer des données au format JSON

Rendu côté serveur
Rendu dans les Web Workers
Application mobile

Zones
Directives avancées
Injection de dépendances avancée

OPTIONNELS (5 jours)

Animations : états, transitions et animations avec le routeur
Material design
Bibliothèques de Composants
Server-side rendering avec Angular Universal
Compilation statique des templates (AOT)

== Objectifs

● Découvrir les fonctionnalités du framework Angular2
● Savoir développer une nouvelle application Web de façon autonome
● Savoir concevoir une application Angular2 avec JavaScript et TypeScript
● Connaître les mécanismes avancés du framework
Savoir commmuniquer avec un serveur
Savoir tester son application
Connaître les bonnes pratiques de développement


Théorique

Pratique : TP pour être sur d'avoir compris chaque point.


Liste des exercices NinjaSquad : https://angular-exercises.ninja-squad.com/





== Forms

DOCUMENTATION OFFICIELLE

Form by template https://angular.io/docs/ts/latest/guide/forms.html

NgForm directive API https://angular.io/docs/ts/latest/api/forms/index/NgForm-directive.html

Form reactive (code-driven) https://angular.io/docs/ts/latest/guide/reactive-forms.html

Form validation https://angular.io/docs/ts/latest/cookbook/form-validation.html

